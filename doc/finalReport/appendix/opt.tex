对 STAP++ 的优化我们尝试了如下几个方面：

\begin{itemize}
    \item 组装刚度阵的并行优化尝试（见第八周组会报告）
    \item 组装刚度阵时全同单元的刚度阵重复利用（见第七周组会报告）
    \item 组装稀疏矩阵之后进行 trim 操作（见 Github opt/trim 分支）
    \item 标记稀疏矩阵 columns 时的算法、容器选取优化
    \item 组装单元刚度阵时的算法优化
\end{itemize}

\section{组装刚度阵时的并行优化尝试}
    我们考虑过在组装刚度阵时进行并行优化（见第八周组会报告），虽然组装刚度阵时各单元互相解耦，对公共变量只有读的操作，但是在 scatter 这一步时，对稀疏矩阵存在写入操作，而且是 \texttt{+=} 操作，因此可能会出现写入冲突的问题。

    我们考虑过两个解决方法，一个是利用锁，但是这样多核心的优点发挥不出来，写入时会频繁访问锁，严重影响性能，失去了多线程组装刚度阵的意义。

    另一个方法是将一个线程绑定为 scatter 线程，其余线程指定为组装单元刚度阵的线程。通过一个 FIFO 的队列，完成线程间的协作。
    这样可以通过牺牲一个组装线程来避免掉上一个方法中的访问冲突问题。但是这样做的问题是，每组装一个单元就需要 new 一个数组，这样一来如果线程较多，可能出现 scatter 线程中挤压任务，一核干活多核围观的场景。因此，这种方法我们最终也没有采用。

    答辩时老师指出的分区域划分指派的方法，我们也考虑过，但是因为实现难度较大，我们没有进行深入考虑。最终我们没有将并行组装加入程序。

\section{全同单元的刚度阵重复利用}
    我们还考虑了组装刚度阵时全同单元的刚度阵重复利用（见第七周组会报告）。

    简单来说，因为组合体中可能出现大量尺寸相同、材料相同、朝向相同的单元（如桥面、两侧桥墩），因此对于全同的单元，我们可以重复利用他们的单元刚度阵。
    
    为了实现这个功能，我们的想法是利用 hash 的方法。对每个元素进行 hash，将单元刚度阵挂载到 hash 表对应的地方，从而通过查询 hash 表实现重复利用刚度阵。

    但是这个方法存在三个问题。
    
    第一个问题是算法上难以对单元进行 hash。对单元来说，表征其特征的参数有 \texttt{nodes} 参数和 \texttt{elementMatrial} 参数，后者可以简单用内存地址表示（或是在单元组内用编号表示），但前者需要对每个点的 \texttt{xyz} 进行数值处理（考虑相对尺度，考虑差值），而 \texttt{xyz} 是浮点数，在读入文件时就存在一定的误差，因此难以进行针对整形的 hash 操作。如果将浮点强行转换为整形进行 hash，最坏的情况可能是全部 hash 都 miss 掉，反而成为负优化。

    第二个问题是在进行 hash 时，效率存在很大的浪费。
    首先为了保证刚度阵组装的正确，我们必须考虑 hash 碰撞的问题，需要将 hash 表建立为数组$+$链表的形式，
    而每检测到 hash 相同，我们就必须对他们进行一次比对，确认单元全同才可以进行单刚重复利用，否则存在刚度阵组装错误的风险。
    而比较单元全同的时间并不是很短的，因此这存在一定的性能浪费。

    第三个问题是存在很大的内存浪费。
    为了保存单刚，我们需要对不同的单元保存他们的单元刚度阵，因此考虑一个自由度的相关自由度是 20 的话，我们需要约 10 倍于总刚的空间来保存单刚，
    即不能及时 \texttt{delete} 掉 \texttt{Matrix} 数组。
    就算考虑不对所有单元保存单刚，维护一个计数器，对重复超过了某一个阈值的单元才保留单刚，我们也很难保证内存不炸掉。

    因此，重复利用单刚在现有的输入文件的格式下很难实现。但是对于 ABAQUS 来说，他的输入格式有 part 和 instance 的概念，对这个方法能更好的适应。
    我们只需要保留每一个 part 的刚度阵，进行 part 级别的刚度阵变换和 scatter，就可以一定程度上避免重复刚度阵的计算。
    而且如果进一步考虑，在组装每一个 part 的刚度阵时，可以在 part 内部考虑单元刚度阵的重复利用。因为 part 多是规则的空间取向，点的坐标经常是整数或不存在浮点误差的浮点数（如 $0.5, 0.25, 0.75$），因此 hash 操作更好做，而且要求的储存空间更低。
    从这个意义上来说，我们的 dat 输入文件虽然简单，但是空间效率和计算效率都较 inp 格式的输入文件差。

\section{稀疏矩阵的 trim 操作}

    我们还考虑了在组装稀疏矩阵之后进行 trim 操作（见 Github opt/trim 分支）。

    具体来说，因为单刚中存在零元素，而我们在标记稀疏矩阵零元素时无法判断是否是零元素，因此在最终的总刚中这些零元素被标记为非零元，在稀疏求解器求解的部分 占用了时间。因此，我们考虑在调用稀疏求解器之前进行一次 trim 操作，将这些被标记为非零元的零元素去掉。

    我们虽然实现了这个算法，但是在测试的过程中发现，这个做法并不能起到减少时间的作用，反而降低了程序效率。
    
    分析这些假非零元的数量，在 Job-1 时，假非零元的占比为 16.84\%，Job-2 为 6.68\%，Job-3 为 3.11\%，因此单元划分越细，假非零元越少。
    这符合直觉：假非零元多由梁板壳梁单元等一维或二维单元产生，而随着单元划分加密， 8H 单元的数量占比三次方增大，占到绝对多数，而 8H 单刚多为满阵，因此假非零元减少。

    因此，trim 操作起到的优化效果有限，而进行一次 trim 操作需要遍历一次数组，因此可能遍历操作的花销大于求解器优化时的开销。

    另一个可能的原因是，在 trim 操作遍历数组时发生了 cache miss，这样会严重影响遍历的性能。由于时间和技术限制，我们没有对这方面进行进一步的优化。
